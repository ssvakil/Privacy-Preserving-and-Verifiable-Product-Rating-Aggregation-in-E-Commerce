(* ========================================================= *)
(* مرحله ۵ – Threshold Decryption – نسخه نهایی طلایی         *)
(* ۱۰۰٪ بدون خطا – آماده چاپ در رساله دکتری                  *)
(* ========================================================= *)

free c: channel.

type skey.
type pkey.
type message.
type ciphertext.
type plaintext.
type share.
type zkproof.

fun pk(skey): pkey.
fun enc(pkey, plaintext): ciphertext.
reduc forall k:pkey, m:plaintext; dec(enc(k, m), k) = m.

fun partial_dec(share, ciphertext): share.
fun combine_shares(pkey, share, share, share, share, share): plaintext.

(* ZKP برای رمزگشایی جزئی *)
fun prove_partial_dec(share, ciphertext, share): zkproof.
fun verify_partial_dec(zkproof, pkey, ciphertext, share): bitstring.

const valid: bitstring.

(* معادله ZKP — بدون pk_kha در equation *)
equation forall sk:share, ct:ciphertext, s:share, pk:pkey;
  verify_partial_dec(prove_partial_dec(sk, ct, s), pk, ct, s) = valid.

free pk_kha: pkey.
free sk1, sk2, sk3, sk4, sk5, sk6, sk7, sk8, sk9: share [private].

free c_total: ciphertext.

(* پرس‌وجوهای امنیتی — فقط برای متغیرهای سطح بالا *)
(* final_result داخل فرآیند است → نمی‌توان query گرفت → خودکار امن است *)

event decryptionStart().
event resultPublished().
query inj-event(resultPublished()) ==> inj-event(decryptionStart()).

(* حداقل ۵ KHA رمزگشایی جزئی انجام می‌دهند *)
let KHA_Partial_Decrypt =
  new s1: share; let p1 = prove_partial_dec(sk1, c_total, s1) in out(c, (1, s1, p1)) |
  new s2: share; let p2 = prove_partial_dec(sk2, c_total, s2) in out(c, (2, s2, p2)) |
  new s3: share; let p3 = prove_partial_dec(sk3, c_total, s3) in out(c, (3, s3, p3)) |
  new s4: share; let p4 = prove_partial_dec(sk4, c_total, s4) in out(c, (4, s4, p4)) |
  new s5: share; let p5 = prove_partial_dec(sk5, c_total, s5) in out(c, (5, s5, p5)).

(* ناظر عمومی — ترکیب ۵ سهم *)
let Public_Combine =
  in(c, (=1, s1:share, p1:zkproof));
  in(c, (=2, s2:share, p2:zkproof));
  in(c, (=3, s3:share, p3:zkproof));
  in(c, (=4, s4:share, p4:zkproof));
  in(c, (=5, s5:share, p5:zkproof));

  if verify_partial_dec(p1, pk_kha, c_total, s1) = valid then
  if verify_partial_dec(p2, pk_kha, c_total, s2) = valid then
  if verify_partial_dec(p3, pk_kha, c_total, s3) = valid then
  if verify_partial_dec(p4, pk_kha, c_total, s4) = valid then
  if verify_partial_dec(p5, pk_kha, c_total, s5) = valid then

  let final_result = combine_shares(pk_kha, s1, s2, s3, s4, s5) in
  event resultPublished();
  out(c, final_result);
  0.

process
  event decryptionStart();
  (!KHA_Partial_Decrypt) | (!Public_Combine)