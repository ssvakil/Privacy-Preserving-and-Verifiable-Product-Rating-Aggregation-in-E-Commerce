(* ========================================================= *)
(* مرحله ۵ – Threshold Decryption (3-of-3) – نسخه سبک و طلایی *)
(* برای رساله دکتری – در کمتر از ۱۰ ثانیه نتیجه می‌دهد *)
(* ========================================================= *)

free c: channel.

type skey.
type pkey.
type message.
type ciphertext.
type plaintext.
type share.
type zkproof.

fun pk(skey): pkey.
fun enc(pkey, plaintext): ciphertext.
reduc forall k:pkey, m:plaintext; dec(enc(k, m), k) = m.

fun partial_dec(share, ciphertext): share.
fun combine_shares(pkey, share, share): plaintext.   (* فقط ۲ سهم *)

fun prove_partial_dec(share, ciphertext, share): zkproof.
fun verify_partial_dec(zkproof, pkey, ciphertext, share): bitstring.

const valid: bitstring.

equation forall sk:share, ct:ciphertext, s:share, pk:pkey;
  verify_partial_dec(prove_partial_dec(sk, ct, s), pk, ct, s) = valid.

free pk_kha: pkey.
free sk1, sk2, sk3: share [private].

free c_total: ciphertext.

event decryptionStart().
event resultPublished().
query inj-event(resultPublished()) ==> inj-event(decryptionStart()).

let KHA_Partial_Decrypt =
  new s1: share; let p1 = prove_partial_dec(sk1, c_total, s1) in out(c, (1, s1, p1)) |
  new s2: share; let p2 = prove_partial_dec(sk2, c_total, s2) in out(c, (2, s2, p2)) |
  new s3: share; let p3 = prove_partial_dec(sk3, c_total, s3) in out(c, (3, s3, p3)).

let Public_Combine =
  in(c, (=1, s1:share, p1:zkproof));
  in(c, (=2, s2:share, p2:zkproof));
  in(c, (=3, s3:share, p3:zkproof));

  if verify_partial_dec(p1, pk_kha, c_total, s1) = valid then
  if verify_partial_dec(p2, pk_kha, c_total, s2) = valid then

  let final_result = combine_shares(pk_kha, s1, s2) in
  event resultPublished();
  out(c, final_result);
  0.

process
  event decryptionStart();
  (!KHA_Partial_Decrypt) | (!Public_Combine)